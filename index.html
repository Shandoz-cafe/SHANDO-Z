<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üõ†Ô∏è Maintenance - Temple Run 2 üõ†Ô∏è</title>
    <style>
        * { touch-action: none; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0; overflow: hidden;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 50%, #74C69D 100%);
            font-family: system-ui, sans-serif;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            min-height: 100vh; user-select: none; touch-action: none;
        }
        canvas { 
            display: block; max-width: 100vw; max-height: 100vh; 
            border: 3px solid #2c3e50; border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            touch-action: none;
        }
        #ui {
            position: absolute; top: 15px; left: 15px; right: 15px;
            display: flex; justify-content: space-between; color: #2c3e50;
            font-weight: bold; font-size: 18px; z-index: 100;
            background: rgba(255,255,255,0.95); padding: 10px 15px;
            border-radius: 12px; backdrop-filter: blur(10px);
        }
        #message {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            text-align: center; color: #2c3e50; background: rgba(255,255,255,0.95);
            padding: 12px 20px; border-radius: 12px; font-size: 14px;
            max-width: 90vw; box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        #restart {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            padding: 20px 40px; background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white; border: none; border-radius: 15px; font-size: 22px;
            font-weight: bold; cursor: pointer; z-index: 200; display: none;
            box-shadow: 0 10px 30px rgba(231,76,60,0.4);
        }
        #restart:active { transform: translate(-50%,-48%); }
    </style>
</head>
<body>
    <div id="message">
        üõ†Ô∏è <strong>Website Sedang Maintenance</strong> üõ†Ô∏è<br>
        <small>Swipe ‚Üë lompat | ‚Üì slide | ‚Üê‚Üí lane | SPACE/Click lompat</small>
    </div>
    <div id="ui">
        <span>Score: <span id="score">0</span></span>
        <span>Coins: <span id="coins">0</span></span>
    </div>
    <canvas id="game"></canvas>
    <button id="restart" onclick="restartGame()">üîÑ MAIN LAGI</button>

    <script>
        class TempleRun {
            constructor() {
                this.canvas = document.getElementById('game');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                this.reset();
                this.initControls();
                this.loop();
            }

            resize() {
                const dpi = window.devicePixelRatio || 1;
                const maxW = window.innerWidth * 0.95;
                const maxH = window.innerHeight * 0.75;
                const size = Math.min(maxW, maxH / 0.5625);
                
                this.canvas.width = size * dpi;
                this.canvas.height = (size * 0.5625) * dpi;
                this.canvas.style.width = size + 'px';
                this.canvas.style.height = (size * 0.5625) + 'px';
                this.ctx.scale(dpi, dpi);
                this.scale = size / 800;
                this.lanes = [150 * this.scale, 300 * this.scale, 450 * this.scale];
            }

            reset() {
                this.player = { x: 0, y: 320 * this.scale, w: 40 * this.scale, h: 60 * this.scale, 
                               lane: 1, vy: 0, slide: 0, boost: 0, shield: false, rot: 0 };
                this.obstacles = []; this.coins = []; this.monkey = -300 * this.scale;
                this.score = 0; this.coinsC = 0; this.speed = 5; this.gameOver = false;
                this.spawnT = 0; this.lastTime = 0;
                updateUI(0, 0);
                document.getElementById('restart').style.display = 'none';
            }

            initControls() {
                window.addEventListener('resize', () => this.resize());
                
                // Keyboard
                document.addEventListener('keydown', e => {
                    if (this.gameOver) return;
                    e.preventDefault();
                    if (e.code === 'Space') this.jump();
                    else if (e.code === 'ArrowDown') this.slide();
                    else if (e.code === 'ArrowLeft' && this.player.lane > 0) this.player.lane--;
                    else if (e.code === 'ArrowRight' && this.player.lane < 2) this.player.lane++;
                });

                // Touch
                let touchStart = { x: 0, y: 0 };
                this.canvas.addEventListener('touchstart', e => {
                    e.preventDefault();
                    const t = e.touches[0];
                    touchStart = { x: t.clientX, y: t.clientY };
                    if ('vibrate' in navigator) navigator.vibrate(10);
                });
                this.canvas.addEventListener('touchend', e => {
                    e.preventDefault();
                    if (this.gameOver || !touchStart.x) return;
                    const t = e.changedTouches[0];
                    const dx = t.clientX - touchStart.x;
                    const dy = t.clientY - touchStart.y;
                    
                    if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
                        if (dx > 0 && this.player.lane < 2) this.player.lane++;
                        else if (dx < 0 && this.player.lane > 0) this.player.lane--;
                    } else if (dy > 30) {
                        this.slide();
                    } else if (dy < -30) {
                        this.jump();
                    }
                    if ('vibrate' in navigator) navigator.vibrate(20);
                });

                // Mouse
                this.canvas.addEventListener('click', () => !this.gameOver && this.jump());
            }

            jump() {
                if (this.player.y >= 320 * this.scale - 10) {
                    this.player.vy = -20 * this.scale;
                    if ('vibrate' in navigator) navigator.vibrate(30);
                }
            }

            slide() {
                if (!this.player.slide) {
                    this.player.slide = 25;
                    if ('vibrate' in navigator) navigator.vibrate(40);
                }
            }

            update(dt) {
                if (this.gameOver) return;

                // Player physics
                this.player.rot += 0.2;
                this.player.vy += 1 * this.scale;
                this.player.y += this.player.vy;
                if (this.player.y > 320 * this.scale) {
                    this.player.y = 320 * this.scale;
                    this.player.vy *= 0.7;
                }

                if (this.player.slide > 0) {
                    this.player.slide--;
                    this.player.h = 30 * this.scale;
                    this.player.y += 30 * this.scale;
                } else {
                    this.player.h = 60 * this.scale;
                    if (this.player.y < 320 * this.scale) this.player.y -= 30 * this.scale;
                }

                this.player.x = this.lanes[this.player.lane];

                // Game speed
                this.score += this.speed * dt;
                this.speed += 0.02 * dt;
                this.monkey += this.speed * 1.5 * dt;

                // Spawn
                this.spawnT += this.speed * dt;
                if (this.spawnT > 120) {
                    this.spawnT = 0;
                    const lane = Math.floor(Math.random() * 3);
                    if (Math.random() < 0.7) {
                        this.obstacles.push({
                            x: this.lanes[lane], y: 360 * this.scale,
                            w: (40 + Math.random() * 30) * this.scale,
                            h: (50 + Math.random() * 30) * this.scale,
                            type: Math.random() < 0.5 ? 'rock' : 'fire'
                        });
                    } else {
                        this.coins.push({
                            x: this.lanes[lane] + 10 * this.scale,
                            y: (250 + Math.random() * 80) * this.scale,
                            spin: 0
                        });
                    }
                }

                // Update objects
                this.obstacles.forEach((o, i) => {
                    o.x -= this.speed * dt;
                    if (o.x < -100 * this.scale) this.obstacles.splice(i, 1);
                });
                this.coins.forEach((c, i) => {
                    c.x -= this.speed * dt;
                    c.spin += 0.2;
                    if (c.x < -50 * this.scale) this.coins.splice(i, 1);
                });

                // Collisions
                const px = this.player.x, py = this.player.y;
                this.obstacles.forEach(o => {
                    if (Math.hypot(px - o.x, py - (360 * this.scale - o.h)) < 40 * this.scale) {
                        if (this.player.shield) this.player.shield = false;
                        else {
                            this.gameOver = true;
                            if ('vibrate' in navigator) navigator.vibrate(200);
                            document.getElementById('restart').style.display = 'block';
                        }
                    }
                });
                this.coins.forEach((c, i) => {
                    if (Math.hypot(px - c.x, py - c.y) < 25 * this.scale) {
                        this.coins.splice(i, 1);
                        this.coinsC++;
                        updateUI(Math.floor(this.score), this.coinsC);
                        if ('vibrate' in navigator) navigator.vibrate(50);
                    }
                });

                if (this.monkey > px - 50 * this.scale) {
                    this.gameOver = true;
                    document.getElementById('restart').style.display = 'block';
                }

                updateUI(Math.floor(this.score), this.coinsC);
            }

            draw() {
                const ctx = this.ctx;
                const w = 800 * this.scale, h = 450 * this.scale;
                ctx.clearRect(0, 0, w / this.scale, h / this.scale);

                // Background
                const grad = ctx.createLinearGradient(0, 0, 0, h);
                grad.addColorStop(0, '#87CEEB'); grad.addColorStop(0.6, '#98D8C8'); grad.addColorStop(1, '#74C69D');
                ctx.fillStyle = grad; ctx.fillRect(0, 0, w, h);

                // Clouds
                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                for (let i = 0; i < 5; i++) {
                    const x = ((this.score * 0.1 + i * 200) % 800) * this.scale;
                    ctx.beginPath();
                    ctx.arc(x, 60 * this.scale, 25 * this.scale, 0, Math.PI * 2);
                    ctx.arc(x + 20 * this.scale, 60 * this.scale, 30 * this.scale, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Ground
                ctx.fillStyle = '#27ae60'; ctx.fillRect(0, 370 * this.scale, w, 80 * this.scale);
                ctx.fillStyle = '#2ecc71';
                for (let i = 0; i < 30; i++) {
                    const x = ((this.score * 3 + i * 35) % 800) * this.scale;
                    ctx.fillRect(x, 385 * this.scale, 30 * this.scale, 8 * this.scale);
                }

                // Player
                ctx.save(); ctx.translate(this.player.x, this.player.y);
                ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 10 * this.scale;
                
                if (this.player.slide) {
                    ctx.fillStyle = '#3498db'; ctx.fillRect(-20 * this.scale, 0, 40 * this.scale, 25 * this.scale);
                    ctx.fillStyle = '#f1c40f'; ctx.beginPath();
                    ctx.arc(0, -15 * this.scale, 12 * this.scale, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.fillStyle = '#34495e';
                    ctx.fillRect(-12 * this.scale, 15 * this.scale, 8 * this.scale, 25 * this.scale);
                    ctx.fillRect(4 * this.scale, 15 * this.scale - Math.sin(this.player.rot) * 8 * this.scale, 8 * this.scale, 25 * this.scale);
                    ctx.fillStyle = '#3498db'; ctx.fillRect(-18 * this.scale, -5 * this.scale, 36 * this.scale, 30 * this.scale);
                    ctx.fillStyle = '#f1c40f'; ctx.beginPath();
                    ctx.arc(0, -25 * this.scale, 15 * this.scale, 0, Math.PI * 2); ctx.fill();
                }
                ctx.shadowBlur = 0; ctx.restore();

                // Coins
                ctx.save(); ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 15 * this.scale;
                this.coins.forEach(c => {
                    ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(c.spin);
                    ctx.fillStyle = '#ffd700'; ctx.beginPath();
                    ctx.arc(0, 0, 12 * this.scale, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                });
                ctx.shadowBlur = 0; ctx.restore();

                // Obstacles
                this.obstacles.forEach(o => {
                    ctx.save(); ctx.translate(o.x, 360 * this.scale);
                    ctx.shadowColor = o.type === 'rock' ? '#654321' : '#ff4500'; ctx.shadowBlur = 12 * this.scale;
                    if (o.type === 'rock') {
                        ctx.fillStyle = '#8B4513'; ctx.fillRect(-o.w/2, -o.h, o.w, o.h);
                    } else {
                        ctx.fillStyle = '#ff4500'; ctx.beginPath();
                        ctx.moveTo(-o.w/2, -o.h); ctx.lineTo(o.w/2, -o.h); ctx.lineTo(0, 0); ctx.fill();
                    }
                    ctx.shadowBlur = 0; ctx.restore();
                });

                // Monkey
                ctx.save(); ctx.translate(this.monkey, 380 * this.scale);
                ctx.fillStyle = '#4a4a4a'; ctx.fillRect(-25 * this.scale, -15 * this.scale, 50 * this.scale, 40 * this.scale);
                ctx.fillStyle = '#ff6b6b'; ctx.beginPath();
                ctx.arc(-10 * this.scale, -20 * this.scale, 8 * this.scale, 0, Math.PI * 2);
                ctx.arc(10 * this.scale, -20 * this.scale, 8 * this.scale, 0, Math.PI * 2); ctx.fill();
                ctx.restore();

                if (this.gameOver) {
                    ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0, 0, w, h);
                    ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.font = `bold ${48 * this.scale}px Arial`; ctx.fillText('GAME OVER', 400 * this.scale, 225 * this.scale);
                    ctx.font = `${32 * this.scale}px Arial`; ctx.fillText(`Score: ${Math.floor(this.score)}`, 400 * this.scale, 270 * this.scale);
                    ctx.textAlign = 'left';
                }
            }

            loop(time = 0) {
                const dt = Math.min((time - this.lastTime) / 16.67, 3);
                this.lastTime = time;
                this.update(dt);
                this.draw();
                requestAnimationFrame(t => this.loop(t));
            }
        }

        const game = new TempleRun();
        function updateUI(score, coins) {
            document.getElementById('score').textContent = score;
            document.getElementById('coins').textContent = coins;
        }
        function restartGame() { game.reset(); }
    </script>
</body>
</html>
