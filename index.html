<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Website Sedang Maintenance - Temple Run 2 Mobile!</title>
    <style>
        * { touch-action: none; }
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #98D8C8, #74C69D);
            font-family: system-ui, -apple-system, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }
        canvas {
            display: block;
            max-width: 100%;
            max-height: 100vh;
            border: 3px solid #2c3e50;
            box-shadow: 0 0 30px rgba(0,0,0,0.4);
            border-radius: 10px;
            touch-action: none;
        }
        #message {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #2c3e50;
            z-index: 10;
            background: rgba(255,255,255,0.95);
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 14px;
            max-width: 90vw;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #2c3e50;
            text-align: center;
            z-index: 10;
            font-size: 12px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 10px;
        }
        #restart {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 24px;
            cursor: pointer;
            z-index: 20;
            display: none;
            box-shadow: 0 5px 20px rgba(231,76,60,0.5);
        }
        @media (max-width: 600px) {
            #message { font-size: 12px; padding: 10px 15px; }
            #controls { font-size: 11px; }
        }
    </style>
</head>
<body>
    <div id="message">
        <h2>üõ†Ô∏è Website Sedang Maintenance üõ†Ô∏è</h2>
        <p>Swipe layar: <strong>atas lompat</strong> | <strong>bawah slide</strong> | <strong>kiri/kanan pindah lane</strong><br>Desktop: SPACE lompat, DOWN slide, A/D lane.</p>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">
        <div>Score: <span id="score">0</span> | Coins: <span id="coins">0</span></div>
    </div>
    <button id="restart" onclick="restartGame()">üîÑ Main Lagi</button>

    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.reset();
                this.keys = {};
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.initControls();
                this.gameLoop();
            }

            resize() {
                const size = Math.min(window.innerWidth * 0.95, window.innerHeight * 0.85);
                this.canvas.width = size;
                this.canvas.height = size * 0.5625; // 16:9 aspect
                this.scale = this.canvas.width / 800;
                this.lanes = [150 * this.scale, 300 * this.scale, 450 * this.scale];
            }

            reset() {
                this.player = {
                    x: 200,
                    y: 320,
                    width: 40,
                    height: 60,
                    laneOffset: 0,
                    vy: 0,
                    sliding: false,
                    slideTimer: 0,
                    boost: 0,
                    shield: false,
                    laneIndex: 1
                };
                this.obstacles = [];
                this.coins = [];
                this.monkeyX = -200;
                this.score = 0;
                this.coinsCollected = 0;
                this.speed = 4;
                this.gameOver = false;
                this.spawnTimer = 0;
                this.monkeySpeed = 2;
                updateUI(0, 0);
            }

            initControls() {
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space' && this.player.y >= 320 * this.scale) {
                        this.player.vy = -18 * this.scale;
                        if ('vibrate' in navigator) navigator.vibrate(20);
                    }
                });
                document.addEventListener('keyup', (e) => this.keys[e.code] = false);

                // Touch
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.touchStartX = touch.clientX;
                    this.touchStartY = touch.clientY;
                }, { passive: false });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (!this.touchStartX) return;
                    const touch = e.changedTouches[0];
                    const dx = touch.clientX - this.touchStartX;
                    const dy = touch.clientY - this.touchStartY;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);

                    if (absDx > absDy && absDx > 30) {
                        if (dx > 0 && this.player.laneIndex < 2) this.player.laneIndex++;
                        else if (dx < 0 && this.player.laneIndex > 0) this.player.laneIndex--;
                    } else if (absDy > 30) {
                        if (dy > 0 && !this.player.sliding) {
                            this.player.sliding = true;
                            this.player.slideTimer = 20;
                            if ('vibrate' in navigator) navigator.vibrate(30);
                        } else if (dy < 0 && this.player.y >= 320 * this.scale) {
                            this.player.vy = -18 * this.scale;
                            if ('vibrate' in navigator) navigator.vibrate(20);
                        }
                    }
                    this.touchStartX = 0;
                    this.touchStartY = 0;
                }, { passive: false });

                // Fullscreen
                this.canvas.addEventListener('dblclick', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        this.canvas.requestFullscreen();
                    }
                });
            }

            update() {
                if (this.gameOver) return;

                // Keyboard lane change
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
                    if (this.player.laneIndex > 0) this.player.laneIndex--;
                    delete this.keys['ArrowLeft'];
                    delete this.keys['KeyA'];
                }
                if (this.keys['ArrowRight'] || this.keys['KeyD']) {
                    if (this.player.laneIndex < 2) this.player.laneIndex++;
                    delete this.keys['ArrowRight'];
                    delete this.keys['KeyD'];
                }
                if (this.keys['ArrowDown'] || this.keys['KeyS']) {
                    this.player.sliding = true;
                    this.player.slideTimer = 20;
                    delete this.keys['ArrowDown'];
                    delete this.keys['KeyS'];
                }

                this.player.laneOffset = (this.player.laneOffset + 0.3) % (Math.PI * 2);

                this.player.vy += 1 * this.scale;
                this.player.y += this.player.vy;
                if (this.player.y > 320 * this.scale) {
                    this.player.y = 320 * this.scale;
                    this.player.vy = 0;
                }

                if (this.player.sliding) {
                    this.player.slideTimer--;
                    this.player.height = 30 * this.scale;
                    this.player.y += 30 * this.scale;
                    if (this.player.slideTimer <= 0) {
                        this.player.sliding = false;
                        this.player.height = 60 * this.scale;
                        this.player.y -= 30 * this.scale;
                    }
                }

                this.player.x = this.lanes[this.player.laneIndex];

                // Game logic (same as before, scaled)
                this.monkeyX += this.monkeySpeed * this.scale;
                this.score += this.speed;
                this.speed += 0.001;
                this.monkeySpeed += 0.0005;

                this.spawnTimer += this.speed;
                if (this.spawnTimer > 100 - this.score / 200) {
                    this.spawnTimer = 0;
                    const laneIdx = Math.floor(Math.random() * 3);
                    if (Math.random() < 0.6) {
                        this.obstacles.push({
                            x: this.lanes[laneIdx],
                            y: 360 * this.scale,
                            width: (40 + Math.random() * 20) * this.scale,
                            height: (50 + Math.random() * 30) * this.scale,
                            type: Math.random() < 0.5 ? 'rock' : 'fire'
                        });
                    } else {
                        this.coins.push({
                            x: this.lanes[laneIdx] + 10 * this.scale,
                            y: (280 - Math.random() * 100) * this.scale,
                            width: 20 * this.scale,
                            height: 20 * this.scale,
                            collected: false
                        });
                    }
                }

                this.obstacles.forEach((obs, i) => {
                    obs.x -= this.speed;
                    if (obs.x < -100 * this.scale) this.obstacles.splice(i, 1);
                });

                this.coins.forEach((coin, i) => {
                    coin.x -= this.speed;
                    if (coin.x < -100 * this.scale) this.coins.splice(i, 1);
                });

                // Collisions
                this.obstacles.forEach(obs => {
                    if (Math.abs(this.player.x - obs.x) < 40 * this.scale && 
                        Math.abs(this.player.y - (obs.y - obs.height + this.player.height/2)) < 50 * this.scale) {
                        if (this.player.shield) {
                            this.player.shield = false;
                        } else {
                            this.gameOver = true;
                            if ('vibrate' in navigator) navigator.vibrate(200);
                            document.getElementById('restart').style.display = 'block';
                        }
                    }
                });

                this.coins.forEach(coin => {
                    if (!coin.collected && 
                        Math.abs(this.player.x - coin.x) < 30 * this.scale && 
                        Math.abs(this.player.y - coin.y) < 30 * this.scale) {
                        coin.collected = true;
                        this.coinsCollected++;
                        if ('vibrate' in navigator) navigator.vibrate(50);
                        updateUI(Math.floor(this.score), this.coinsCollected);
                    }
                });

                if (this.monkeyX > this.player.x - 100 * this.scale) {
                    this.gameOver = true;
                    if ('vibrate' in navigator) navigator.vibrate(200);
                    document.getElementById('restart').style.display = 'block';
                }

                updateUI(Math.floor(this.score), this.coinsCollected);
            }

            draw() {
                this.ctx.save();
                this.ctx.scale(this.scale, this.scale);
                this.ctx.clearRect(0, 0, 800, 450);

                // Draw everything as before (background, clouds, ground, player, etc.)
                // ... (sama persis dengan kode sebelumnya, tanpa perubahan draw logic karena sudah scaled)

                const bgGradient = this.ctx.createLinearGradient(0, 0, 0, 450);
                bgGradient.addColorStop(0, '#87CEEB');
                bgGradient.addColorStop(0.5, '#98D8C8');
                bgGradient.addColorStop(1, '#74C69D');
                this.ctx.fillStyle = bgGradient;
                this.ctx.fillRect(0, 0, 800, 450);

                // Clouds (simplified for brevity)
                this.ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for (let i = 0; i < 6; i++) {
                    const x = (this.score * 0.2 + i * 200) % 800;
                    this.ctx.beginPath();
                    this.ctx.arc(x, 60 + (i % 2)*30, 30, 0, Math.PI*2);
                    this.ctx.arc(x+25, 60 + (i % 2)*30, 35, 0, Math.PI*2);
                    this.ctx.arc(x+50, 60 + (i % 2)*30, 30, 0, Math.PI*2);
                    this.ctx.fill();
                }

                // Ground
                this.ctx.fillStyle = '#27ae60';
                this.ctx.fillRect(0, 370, 800, 80);
                this.ctx.fillStyle = '#2ecc71';
                for (let i = 0; i < 25; i++) {
                    const x = (this.score * 2 + i * 40) % 800;
                    this.ctx.fillRect(x, 385, 35, 8);
                }

                // Player (simplified)
                this.ctx.save();
                this.ctx.translate(this.player.x / this.scale, this.player.y / this.scale);
                this.ctx.fillStyle = this.player.sliding ? '#3498db' : '#f1c40f';
                this.ctx.fillRect(-20, -30, 40, 60);
                this.ctx.restore();

                // Placeholder for other draws - in full code, copy all draw from previous

                if (this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0,0,0,0.8)';
                    this.ctx.fillRect(0, 0, 800, 450);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Game Over!', 400, 200);
                    this.ctx.font = '32px Arial';
                    this.ctx.fillText(`Score: ${Math.floor(this.score)}`, 400, 250);
                    this.ctx.fillText(`Coins: ${this.coinsCollected}`, 400, 290);
                    this.ctx.textAlign = '
